<h1>Conversation AI: State Machine Documentation</h1>

<h2>Описание проекта</h2>
<p><strong>Conversation AI</strong> — это Telegram-бот, разработанный для автоматизации переговоров с блогерами о стоимости рекламных интеграций. Бот использует конечный автомат (State Machine), построенный на базе <code>LangGraph</code>, для управления диалогом и достижения цели — получения минимальной цены за интеграцию (в формате фиксированной ставки или CPM) или явного отказа от сотрудничества. Бот взаимодействует с пользователем через Telegram с помощью библиотеки <code>Aiogram</code>, а для обработки текстовых ответов и принятия решений используется <code>OpenAI API</code>.</p>

<h3>Основные возможности</h3>
<ul>
    <li>Обработка пользовательских сообщений через Telegram.</li>
    <li>Управление диалогом с помощью конечного автомата (<code>LangGraph</code>).</li>
    <li>Расчёт ценовых предложений на основе входных данных (желаемый CPM клиента и просмотры блогера).</li>
    <li>Поддержка двух форматов сделок: фиксированная цена (фикс) и CPM с установленным лимитом (cap).</li>
    <li>Генерация текстовых ответов с использованием <code>OpenAI API</code>.</li>
    <li>Ведение переговоров до достижения согласия или отказа.</li>
    <li>Формирование итогового сообщения с результатами переговоров.</li>
</ul>

<h2>Бизнес-задача</h2>
<p>Разработать AI-систему, которая:</p>
<ul>
    <li>Ведёт переписку с блогером от лица клиента.</li>
    <li>Договаривается о минимальной цене за рекламную интеграцию, ориентируясь на желаемую стоимость за 1000 просмотров (CPM).</li>
    <li>Завершает диалог при получении минимальной цены или явного отказа от сотрудничества.</li>
</ul>

<h2>Требования</h2>
<ul>
    <li><strong>Python</strong>: 3.10 или выше.</li>
    <li><strong>Библиотеки</strong>:
        <ul>
            <li><code>aiogram</code> — для работы с Telegram API.</li>
            <li><code>langgraph</code> — для реализации конечного автомата.</li>
            <li><code>openai</code> — для генерации ответов и анализа намерений пользователя.</li>
            <li><code>pydantic</code> — для валидации входных данных.</li>
        </ul>
    </li>
    <li><strong>Токены и настройки</strong>:
        <ul>
            <li>Telegram Bot API Token (получается через BotFather).</li>
            <li>OpenAI API Key (получается в аккаунте OpenAI).</li>
        </ul>
    </li>
    <li><strong>Файл <code>.env</code></strong> с переменными:
        <pre>
TELEGRAM_TOKEN=your_telegram_bot_token
OPEN_AI_TOKEN=your_openai_api_key
        </pre>
    </li>
</ul>

<h2>Установка</h2>
<ol>
    <li><strong>Клонируйте репозиторий</strong>:
        <pre>git clone &lt;repository_url&gt;
cd conversation-ai</pre>
    </li>
    <li><strong>Установите зависимости</strong>:
        <pre>pip install -r requirements.txt</pre>
    </li>
    <li><strong>Создайте файл <code>.env</code></strong> в корневой директории проекта:
        <pre>
TG_BOT_TOKEN="your_token"
LANGCHAIN_API_KEY="your_api_key"
LANGSMITH_TRACING=true
LANGSMITH_ENDPOINT="https://api.smith.langchain.com"
LANGSMITH_API_KEY="your_api_key"
LANGSMITH_PROJECT="your_api_key"
OPENAI_API_KEY="your_api_key"
</pre>
    </li>
    <li><strong>Запустите бота</strong>:
        <pre>python main.py</pre>
    </li>
</ol>

<h2>Схема работы</h2>
<ol>
    <li>Пользователь запускает бота командой <code>/start</code>.</li>
    <li>Бот запрашивает входные данные:
        <ul>
            <li>Желаемая стоимость за 1000 просмотров (CPM).</li>
            <li>Количество просмотров блогера (точное число или диапазон, например, 5,000–10,000).</li>
        </ul>
    </li>
    <li>Бот отправляет приветственное сообщение: <em>"Hey, please, provide your desired rate."</em></li>
    <li>Пользователь (в роли блогера) отвечает, предлагая свою цену или условия.</li>
    <li>Бот анализирует ответ с помощью <code>OpenAI API</code>, определяет намерение (согласие, отказ, предложение цены и т.д.) и переходит в соответствующее состояние конечного автомата.</li>
    <li>Бот ведёт переговоры, предлагая:
        <ul>
            <li>Фиксированную цену, рассчитанную по формуле: <code>((CPM * (((min_views + max_views) / 2) + max_views) / 2) / 1000)</code>.</li>
            <li>CPM-сделку с лимитом (cap), рассчитанным по той же формуле.</li>
            <li>При необходимости увеличивает предложение (на 20%, затем на 10% для фикса; на 30% для cap в CPM-сделке).</li>
        </ul>
    </li>
    <li>Диалог завершается, когда:
        <ul>
            <li>Блогер соглашается на предложенные условия.</li>
            <li>Блогер явно отказывается от сотрудничества.</li>
        </ul>
    </li>
    <li>Бот формирует итоговое сообщение с полями:
        <ul>
            <li>Решение (согласие или отказ с причиной).</li>
            <li>Стоимость.</li>
            <li>Формат (фикс или CPM).</li>
        </ul>
    </li>
</ol>

<h2>Диаграмма активности</h2>
<p>Полная схема конечного автомата представлена в Miro: <a href="#">Ссылка на диаграмму в Miro</a> (замените на актуальную ссылку).</p>

<h2>Структура проекта</h2>
<pre>
conversation-ai/
├── ai.py              # Логика взаимодействия с OpenAI API
├── chains/           # Цепочки LangChain для обработки ответов
├── core/             # Конфигурация и настройки
│   └── settings.py   # Настройки через pydantic
├── graph.py          # Определение конечного автомата (LangGraph)
├── main.py           # Точка входа, запуск бота
├── nodes/            # Ноды конечного автомата (по одной на состояние)
│   ├── start.py      # Нода для обработки команды /start
│   ├── input.py      # Нода для обработки входных данных
│   ├── negotiate.py  # Нода для переговоров
│   └── finalize.py   # Нода для формирования итогового сообщения
├── state.py          # Определение состояния конечного автомата
├── requirements.txt  # Зависимости
├── Readme.md         # Краткое описание проекта
└── .env              # Переменные окружения
</pre>

<h2>Механика переговоров</h2>
<h3>Форматы сделок</h3>
<h4>Фиксированная цена (фикс)</h4>
<ul>
    <li>Если блогер предлагает цену, соответствующую минимальному бюджету (<code>(CPM * min_views) / 1000</code>), бот сразу соглашается.</li>
    <li>Если цена превышает бюджет, бот предлагает встречную ставку:
        <pre>((CPM * (((min_views + max_views) / 2) + max_views) / 2) / 1000)</pre>
    </li>
    <li>При отказе блогера:
        <ul>
            <li>Увеличивает предложение на 20%.</li>
            <li>Если отказ повторяется, добавляет ещё 10%.</li>
        </ul>
    </li>
    <li>Если блогер не указал цену, бот сразу предлагает ставку по указанной формуле.</li>
</ul>

<h4>CPM-сделка с лимитом (cap)</h4>
<ul>
    <li>Бот предлагает оплату за каждую тысячу просмотров с максимальным лимитом (cap):
        <pre>cap = ((CPM * (((min_views + max_views) / 2) + max_views) / 2) / 1000)</pre>
    </li>
    <li>Если блогер предлагает фиксированную цену, бот переводит переговоры в формат CPM, указывая cap.</li>
    <li>При несогласии с cap:
        <ul>
            <li>Увеличивает cap на 30%.</li>
        </ul>
    </li>
    <li><em>Опционально</em>:
        <ul>
            <li>Если блогера не устраивает CPM-ставка, бот повышает CPM (и cap) на 15%.</li>
            <li>Если блогер отказывается от CPM, бот переходит к обсуждению минимальной фиксированной ставки.</li>
        </ul>
    </li>
</ul>

<h3>Правила расчёта</h3>
<ul>
    <li><strong>Гэп просмотров</strong>: Если нижняя граница диапазона просмотров отличается от верхней более чем в 2 раза (например, 100,000–200,000), это считается "слишком большим гэпом".</li>
    <li><strong>Отклонение от бенчмарков</strong>: Цена считается далёкой от ожидаемой, если она превышает желаемый CPM на 30% или более.</li>
</ul>

<h2>Использование</h2>
<ol>
    <li><strong>Запустите бота</strong>:
        <pre>python main.py</pre>
    </li>
    <li><strong>Взаимодействие в Telegram</strong>:
        <ul>
            <li>Отправьте <code>/start</code> для начала работы.</li>
            <li>Введите желаемый CPM и количество просмотров блогера (например, "1000, 5000-10000").</li>
            <li>Отвечайте на сообщения бота от лица блогера, предлагая цену или условия.</li>
            <li>Получите итоговое сообщение с результатами переговоров.</li>
        </ul>
    </li>
</ol>

<h3>Примеры</h3>
<ul>
    <li><strong>Входные данные</strong>: CPM = 1000, просмотры = 100,000.
        <ul>
            <li>Бот: <em>"Hey, please, provide your desired rate."</em></li>
            <li>Блогер: <em>"I want $150."</em></li>
            <li>Бот: <em>"Your rate seems a bit high. How about $125 based on our benchmarks?"</em></li>
            <li>Блогер: <em>"Okay, I agree to $125."</em></li>
            <li><strong>Итог</strong>: <em>"Decision: Agreed, Cost: $125, Format: Fixed."</em></li>
        </ul>
    </li>
    <li><strong>Блогер</strong>: <em>"I’m not interested in collaboration."</em>
        <ul>
            <li><strong>Итог</strong>: <em>"Decision: Declined, Reason: Blogger refused collaboration."</em></li>
        </ul>
    </li>
</ul>

<h2>Принципы организации кода</h2>
<ul>
    <li><strong>Разделение слоёв</strong>:
        <ul>
            <li><strong>Presentation</strong>: <code>Aiogram</code> для обработки сообщений Telegram.</li>
            <li><strong>AI</strong>: <code>LangChain/LLM</code> с использованием <code>OpenAI API</code> для анализа намерений и генерации ответов.</li>
            <li><strong>Business Logic</strong>: <code>LangGraph</code> для управления состояниями и расчёта цен.</li>
        </ul>
    </li>
    <li><strong>Модульность</strong>:
        <ul>
            <li>Каждая нода конечного автомата реализована в отдельном файле (<code>nodes/</code>).</li>
            <li>Логика расчётов и принятия решений отделена от генерации текстов.</li>
        </ul>
    </li>
    <li><strong>Чистота кода</strong>:
        <ul>
            <li>Все числовые расчёты выполняются в коде, LLM получает только инструкции и числа.</li>
            <li>Используется структурированный вывод (<code>structured output</code>) для анализа намерений.</li>
        </ul>
    </li>
</ul>
